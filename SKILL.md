---
name: ralph
description: Iterative implementation loop with review checkpoints. Use for multi-step tasks that benefit from chunked execution and verification. Adapts to project-specific conventions via .ralph.md guidance file.
allowed-tools: [Task, Read, Write, Edit, Glob, Grep, Skill, AskUserQuestion, Bash]
---

# Ralph: Iterative Implementation Loop

Execute work through iterative cycles with review checkpoints between chunks.

## Invocation

```
/ralph [state-file]
```

Examples:
- `/ralph plans/my-feature.md` - Execute a plan file
- `/ralph` - Auto-detect state file per project guidance

## When to Use

- Multi-step implementation tasks (3+ work units)
- Plans with clear acceptance criteria or sections
- Tasks benefiting from review checkpoints between chunks
- Work that may span multiple context windows

## When NOT to Use

- **Simple single-step tasks**: One function, one bug fix—just do it directly
- **Exploration/research tasks**: Use Task with `subagent_type: Explore` instead
- **Tasks needing parallel execution**: Inner loops run sequentially; parallel coordination adds context burden without speedup
- **Unclear requirements**: Clarify first, then plan, then ralph
- **Tasks estimated >60 minutes**: Split into separate plans; long sessions hit context exhaustion

## Guardrails

Ralph enforces limits to prevent context exhaustion:

| Threshold | Action |
|-----------|--------|
| 30 minutes | Log warning, suggest checkpoint |
| 45 minutes | Recommend breaking to new session |
| 60 minutes | Force checkpoint, prompt user to split plan |
| 3 consecutive no-progress iterations | Circuit breaker: escalate to user |
| Inner loop max turns (20) | Force exit, return partial summary |

Track iteration progress in state file frontmatter:
```yaml
iterations: 0
no_progress_count: 0
started_at: 2026-01-30T10:00:00Z
```

## Project Guidance

Ralph adapts to project-specific conventions via a `.ralph.md` file.

### Finding .ralph.md

Search in order:
1. **Git repository root**: `git rev-parse --show-toplevel` then check for `.ralph.md`
2. **Walk up from current directory**: Check each parent until `.ralph.md` found or root reached
3. **State file's directory**: If state file provided, check its directory

```bash
# Get git project root
git rev-parse --show-toplevel 2>/dev/null
```

### If No .ralph.md Found

Use AskUserQuestion to offer creating one:

"No `.ralph.md` found for this project. Would you like to create one?"
- **Yes, help me create it** - Ask design questions, generate .ralph.md
- **Use defaults** - Continue with plan-file conventions
- **Skip for now** - Continue without guidance

See `examples/` in this skill's directory for templates and the README for guidance on crafting .ralph.md files.

## The Loop

### 1. LOAD

1. Find and load `.ralph.md` if present (provides project-specific guidance)
2. Read the state file
3. Parse state according to guidance (or use default plan format)

**Default format** (when no .ralph.md):
```yaml
---
status: pending  # pending | in_progress | complete | archived
gaps: []
edge_cases: []
progress: []
last_review: null
iterations: 0
no_progress_count: 0
started_at: null  # Set to current timestamp on first ASSESS
---

# Title

## Section 1
...
```

If file lacks frontmatter, add defaults.

### 2. ASSESS

- Check completion status → if complete/archived, inform user and exit
- Update status to `in_progress` if pending
- **Initialize guardrails** (first iteration only):
  - If `started_at` is null, set to current timestamp (run `date -Iseconds`)
  - If `iterations` is missing, set to 0
- **Check guardrails**:
  - Compare current time to `started_at` → warn at 30min, recommend break at 45min, force checkpoint at 60min
  - Check `no_progress_count` → escalate to user if >= 3
- Identify work units per guidance:
  - **Default**: `## ` headings not in progress array
  - **Per guidance**: acceptance criteria, issues, custom sections
- Group related units if guidance suggests logical groupings
- If all units complete → proceed to final review

**Work unit prioritization:**
1. Resume any `status: partial` unit from previous iteration
2. Pick first incomplete unit in document order
3. If a unit depends on another, complete the dependency first

**Atomic sizing:** Each work unit should fit in one context window. If a unit seems too large (multiple files, complex logic), split it before starting.

### 3. SPAWN INNER LOOP

Use the Task tool to spawn a subagent:

```
Task(
  subagent_type: "general-purpose",
  description: "Implement: [work unit summary]",
  max_turns: 20,
  prompt: [see inner-prompt.md, include project guidance if present]
)
```

Inner loop works until:
- Work unit complete (emit `<promise>UNIT_COMPLETE</promise>`)
- Blocked (needs decision, unclear requirement)
- Max turns reached (hard limit: 20)
- Context feels heavy

**Completion signals:** The `<promise>UNIT_COMPLETE</promise>` tag signals intent; the YAML `status: completed` field in the return summary is canonical. Outer loop checks for both: promise presence confirms the inner loop believes work is done, status field is used for routing logic.

**Subagent limitation:** Inner loops cannot spawn their own subagents. If work requires parallel execution, return to outer loop and let it coordinate.

Returns structured summary (see inner-prompt.md for format).

### 4. REVIEW

Review method per `.ralph.md` guidance. Default: magi synthesis.

```
/magi "Review this implementation work:

## Work Summary
[inner loop's returned summary]

## Work Unit
[what was being implemented]

## Evaluate
1. Implementation correctness - Does it work? Tests pass?
2. Alignment - Did the work match the intended unit?
3. Gap discovery - Any new gaps, edge cases, or TODOs?
4. Completeness - Is the overall work fully realized?

Return structured assessment:
- verdict: pass | fail | needs_work
- gaps_discovered: [list]
- edge_cases_discovered: [list]
- remaining_work: [description]
- recommendation: continue | needs_human_input | archive
- rationale: [brief explanation]"
```

**Fallback (self-review)**: If magi unavailable, review the work yourself using these criteria:
1. **Tests pass?** Run the test suite and verify green
2. **Files changed match intent?** Compare changed files to work unit scope
3. **New gaps?** Grep for TODO, FIXME, or incomplete implementations
4. **Edge cases?** Check error handling and boundary conditions
5. **Verdict**: Apply same pass/fail/needs_work logic as magi would

### 5. UPDATE STATE

Update the state file per guidance:
- **Default**: Update frontmatter arrays (gaps, edge_cases, progress)
- **Per guidance**: Check off criteria, append to sections, etc.

**Update guardrail tracking:**
- Increment `iterations`
- If inner loop returned `status: partial` AND `files_changed` is empty:
  - Increment `no_progress_count`
- Else:
  - Reset `no_progress_count` to 0

Set review timestamp (`last_review`).

### 6. ROUTE

Based on review recommendation:

**`continue`**:
- Add any `gaps_discovered` or `edge_cases_discovered` from review to state file
- Go to step 2

Note: This naturally handles "conditional pass" - issues are tracked and prevent archiving until resolved.

**`needs_human_input`**:
- Use AskUserQuestion to surface the decision
- Present: what was attempted, what needs clarification, options
- After response → step 2

**`archive`** (or equivalent completion):
- Verify no remaining gaps/issues per guidance
- Mark status as `archived` in frontmatter
- Move file to `plans/archived/` (or per guidance)
- Stage only relevant files: state file + files from `files_changed` arrays
- Use AskUserQuestion to confirm commit: "Ready to commit completion of [plan title]. Proceed?"
- If confirmed: `git commit -m "Complete: [plan title]"`
- If issues remain → inform user, continue to step 2

## Completion Criteria

The loop completes when:
1. Review assesses work as "fully realized"
2. No remaining gaps or blockers
3. Per-guidance completion signals sent (if applicable)

## Error Handling

| Scenario | Action |
|----------|--------|
| Magi unavailable | Self-review using fallback criteria |
| Inner loop blocked | Surface via AskUserQuestion |
| State file parse error | Show error, ask user to fix |
| No .ralph.md | Offer to create or use defaults |
| 3+ no-progress iterations | Circuit breaker: stop loop, escalate to user |
| Duration >60 min | Force checkpoint, prompt to split plan |
| Inner loop max turns | Force exit, return partial summary |

**Circuit breaker logic:**
```
if inner_loop.status == "partial" and no files_changed:
  state.no_progress_count += 1
else:
  state.no_progress_count = 0

if state.no_progress_count >= 3:
  AskUserQuestion("Loop stuck after 3 iterations with no progress. Options?")
```

## Manual Control

Interrupt anytime. State file preserves progress. Resume with `/ralph [state-file]`.

## Reference

- `inner-prompt.md` - Inner loop subagent template
- `examples/` - Example .ralph.md files for different project types
- `examples/README.md` - Guide for crafting .ralph.md files
- `docs/ARCHITECTURE.md` - Full architecture documentation
